# PMMX-One (P1) dual encoder with ViT B/16, based on T5 (1.1) Base model.
# Provides MODEL
# ginlint: disable=bad-import-order
from __gin__ import dynamic_registration

import seqio
from t5x import adafactor
from t5x_retrieval import feature_converters
from t5x_retrieval import models
from pmmx import vit_architecture

ARCHITECTURE = %gin.REQUIRED

# MT5 is identical to t5.1.1 architecture except for the vocabulary.
include 't5x_retrieval/configs/architectures/p1_de_t5_1_1_vit_flaxformer.gin'
LEFT_NUM_EMBEDDINGS = 250112  # vocab size rounded to a multiple of 128 for TPU efficiency
RIGHT_NUM_EMBEDDINGS = 250112  # vocab size rounded to a multiple of 128 for TPU efficiency
PROJECTION_DIM=768

# Architecture overrides
NUM_HEADS = 12
NUM_LAYERS = 12
HEAD_DIM = 64
EMBED_DIM = 768
MLP_DIM = 2048

# ViT overrides
VIT_MLP_DIM = 3072
VIT_NUM_LAYERS = 12
VIT_NUM_HEADS = 12
VIT_HIDDEN_SIZE = 768
VIT_PATCHES = {'size': [16, 16]}
VIT_IMAGE_SIZE = (224, 224)
VIT_FROZEN = False

# Vocabulary (shared by encoder and decoder)
VOCABULARY = @seqio.SentencePieceVocabulary()
seqio.SentencePieceVocabulary.sentencepiece_model_file = "gs://t5-data/vocabs/mc4.250000.100extra/sentencepiece.model"

# Optimizer
# `learning_rate` is set by `Trainer.learning_rate_fn`.
OPTIMIZER = @adafactor.Adafactor()
adafactor.Adafactor:
  decay_rate = 0.8
  step_offset = 0
  factor_map = @adafactor.HParamMap()

adafactor.HParamMap:
  rules = @vit_architecture.vit_factor_rules()

T5XR_INFERENCE_MODE = "encode_left"

# Model
MODEL = @models.MultimodalDualEncoderModel()
models.MultimodalDualEncoderModel:
  inference_mode = %T5XR_INFERENCE_MODE
  use_negatives = False
  use_align_uniform = False
  feature_converter_cls = @feature_converters.DualEncoderFeatureConverterFactory()
  module = %ARCHITECTURE
  input_vocabulary = %VOCABULARY
  output_vocabulary = %VOCABULARY
  optimizer_def = %OPTIMIZER
